#' CLPM
#'
#' Creates a cross-lagged panel model from a lavaan-like syntax. The syntax (model)
#' can be fairly complicated to read; use the simplify - function to make it more
#' readable. However, we recommend passing the complex syntax to lavaan instead of
#' the readable one to reduce the likelihood of errors.
#'
#' @param model string specifying the model
#' @param data longitudinal data in long format. Must have a column named 'person'
#' and a column named 'occasion'
#' @param addManifestVar set to "variant" to add manifest variances which are occasion specific
#' (variant). Set to "invariant" to add manifest variances which are equal for all
#' occasions (measurement invariant). Set to "no" to not add any manifest variances (set to 0)
#' @param addLatentVar set to "variant" to add latent variances which are occasion specific
#' (variant). Set to "invariant" to add latent variances which are equal for all
#' occasions (measurement invariant). Set to "no" to not add any latent variances (set to 0)
#' @param meanstructure set to TRUE to add a mean structure
#' @return list with (1) model -> a string with syntax to pass to lavaan as model,
#' (2) data -> a data set in wide format to pass to lavaan, and (3) internal ->
#' internal objects needed for other functions of lessTransformations.
#'
#' @examples
#' # Simulation of a second order model:
#' sim <- simulateExample1()
#'
#' # Let's take a look at the model and the data:
#' cat(sim$model)
#' head(sim$data)
#'
#' # generating the lavaan syntax:
#' clpm <- CLPM(model = sim$model,
#'              data = sim$data)
#'
#' # The syntax generated by CLPM can be quite complicated to read. To simplify
#' # the syntax, use simplify():
#' cat(simplify(clpm$model))
#'
#' # Fit with lavaan:
#' library(lavaan)
#' fit <- sem(model = clpm$model,
#'            data = clpm$data)
#' coef(fit)[unique(names(coef(fit)))]
#' @export
CLPM <- function(model,
                 data,
                 addManifestVar = "variant",
                 addLatentVar = "variant",
                 meanstructure = FALSE){

  cat("\nSetting up a cross-lagged panel model.\n")
  RAM <- lessTransformations:::.CLPM(model = model, data = data)

  if(addManifestVar == "invariant"){
    manifestVar <- diag(RAM@S[RAM@manifest, RAM@manifest])
    tmpLabels <- paste0("mVar_",
                        stringr::str_remove(string = names(manifestVar),
                                            pattern = "_u[0-9]*"))
    manifestVar[manifestVar=="0"] <- tmpLabels[manifestVar=="0"]
    diag(RAM@S[RAM@manifest, RAM@manifest]) <- manifestVar
  }else if(addManifestVar == "variant"){
    manifestVar <- diag(RAM@S[RAM@manifest, RAM@manifest])
    tmpLabels <- paste0("mVar_",
                        names(manifestVar))
    manifestVar[manifestVar=="0"] <- tmpLabels[manifestVar=="0"]
    diag(RAM@S[RAM@manifest, RAM@manifest]) <- manifestVar
  }else if(addManifestVar == "no"){
  }else{
    stop("Unknown addManifestVar. Possible are 'invariant', 'variant', or 'no'.")
  }

  if(addLatentVar == "invariant"){
    latentVar <- diag(RAM@S[RAM@latent, RAM@latent])
    tmpLabels <- paste0("lVar_",
                        stringr::str_remove(string = names(latentVar),
                                            pattern = "_u[0-9]*"))
    latentVar[latentVar=="0"] <- tmpLabels[latentVar=="0"]
    diag(RAM@S[RAM@latent, RAM@latent]) <- latentVar
  }else if(addLatentVar == "variant"){
    latentVar <- diag(RAM@S[RAM@latent, RAM@latent])
    tmpLabels <- paste0("lVar_",
                        names(latentVar))
    latentVar[latentVar=="0"] <- tmpLabels[latentVar=="0"]
    diag(RAM@S[RAM@latent, RAM@latent]) <- latentVar
  }else if(addLatentVar == "no"){
  }else{
    stop("Unknown addLatentVar. Possible are 'invariant', 'variant', or 'no'.")
  }

  cat("Names of the latent variables:", RAM@latent, "\n")
  cat("Names of the manifest variables:", RAM@manifest, "\n")
  lavaanSyntax <- lessTransformations:::.RAM2Lavaan(RAM = RAM, meanstructure = meanstructure)
  dataWide <- try(lessTransformations:::.toWide(data = data, RAM = RAM))
  if(is(object = dataWide, class2 = "try-error")){
    warning("Could not transform your data set from long to wide. Returning only the model")
    return(list(model = lavaanSyntax,
                data = NULL))
  }

  cat("Returning lavaan syntax and data in wide format\n")

  clpm <- list(model = lavaanSyntax,
               data = dataWide,
               internal = list(RAM = RAM,
                               userModel = model))
  class(clpm) <- "CLPM"
  return(clpm)
}

#' .CLPM
#'
#' creates a cross-laged panel model in RAM notation from a syntax similar to that
#' of lavaan.
#'
#' @param model string specifying the model syntax
#' @param data longitudinal data in long format. Must have the columns "person"
#' and "occasion"
#' @return Model in RAM notation
#' @keywords internal
.CLPM <- function(model, data){

  if(!all(c("person", "occasion") %in% colnames(data)))
    stop("Could not find the columns person and occasion in the data set.")
  if(!is(object = data, class2 = "data.frame"))
    data <- as.data.frame(data)

  nOccasions <- length(unique(data$occasion))

  # remove unnecessary white space
  syntax <- lessSEM:::.reduceSyntax(syntax = model)
  syntax <- lessTransformations:::.removeWhitespace(syntax = syntax)
  syntax <- lessTransformations:::.makeSingleLine(syntax = syntax)

  # find the names of all variables
  variableNames <- lessTransformations:::.getVariableNamesCLPM(syntax = syntax)

  latents <- list(
    occasionDependent = variableNames$occasionDependent[!variableNames$occasionDependent %in% colnames(data)],
    fixed = variableNames$fixed[!variableNames$fixed %in% colnames(data)]
  )

  manifests <- list(
    occasionDependent = variableNames$occasionDependent[variableNames$occasionDependent %in% colnames(data)],
    fixed = variableNames$fixed[variableNames$fixed %in% colnames(data)]
  )

  nLatent <- data.frame("occasionDependent" = length(latents$occasionDependent),
                        "fixed" = length(latents$fixed))
  nManifest <- data.frame("occasionDependent" = length(manifests$occasionDependent),
                          "fixed" = length(manifests$fixed))

  # check for measurements of latents:
  for(l in c(latents$occasionDependent, latents$fixed)){

    if(!any(grepl(pattern = paste0(l, "=~|",l, "_\\(u\\)=~"),
                  x = syntax))){
      cat(crayon::red("Note:"), paste0("Could not find a measurement model for ",l, ".\n"))
    }

  }

  # Now that we know the number of variables and the number of measurement occasions,
  # we can set up the matrices

  nRows <- nCols <- nManifest$occasionDependent * nOccasions + nManifest$fixed +
    nLatent$occasionDependent*nOccasions + nLatent$fixed
  varNames <- c(
    paste0(manifests$occasionDependent, "_u", rep(1:nOccasions, each = nManifest$occasionDependent)),
    manifests$fixed,
    paste0(latents$occasionDependent, "_u", rep(1:nOccasions, each = nLatent$occasionDependent)),
    latents$fixed
  )

  A <- matrix("0",
              nrow = nRows,
              ncol = nCols,
              dimnames = list(varNames,
                              varNames))

  S <- A

  M <- A[1,,drop = FALSE]

  Fmat <- matrix(0,
                 nrow = nManifest$occasionDependent * nOccasions + nManifest$fixed,
                 ncol = nCols,
                 dimnames = list(c(paste0(manifests$occasionDependent, "_u", rep(1:nOccasions, each = nManifest$occasionDependent)),
                                   manifests$fixed),
                                 varNames))
  for(i in 1:nrow(Fmat))
    Fmat[i,i] <- 1

  # Let's fill the matrices

  # get all occasion specific elements
  occasions <- data.frame(
    string = unique(unlist(stringr::str_extract_all(string = syntax,
                                                    pattern = "\\(u[-0-9]*\\)"))),
    regex = NA,
    evaluated = NA
  )
  # the following will be used to replace the (u-j) part with another string
  occasions$regex <- stringr::str_replace_all(occasions$string,
                                              pattern = "\\(",
                                              replacement = "\\\\(")
  occasions$regex <- stringr::str_replace_all(occasions$regex,
                                              pattern = "\\)",
                                              replacement = "\\\\)")

  for(u in nOccasions:1){

    # adapt syntax for this specific occasion
    syntax_u <- syntax
    occasions_u <- occasions

    for(i in 1:nrow(occasions)){

      # evaluate (u-j)
      occasions_u$evaluated[i] <- eval(parse(text = occasions_u$string[i]))

      # remove all elements with u below 1
      if(occasions_u$evaluated[i] < 1){
        syntax_u <- stringr::str_replace_all(string = syntax_u,
                                             pattern = paste0("[a-zA-Z0-9_\\(\\)]*[\\*]*[a-zA-Z0-9]+_",occasions_u$regex[i], "[\\+]*"),
                                             replacement = "")
        next
      }

      # replace (u-j) with _u-j
      syntax_u <- stringr::str_replace_all(string = syntax_u,
                                           pattern = occasions_u$regex[i],
                                           replacement = paste0("u", occasions_u$evaluated[i]))
    }

    # remove parts which now end in the operator
    syntax_u <- syntax_u[!grepl(pattern = "[=~]$",
                                x = syntax_u)]

    for(i in 1:length(syntax_u)){
      splitted <- lessTransformations:::.splitEquation(equation = syntax_u[i])

      if(all(splitted$operator == "=~")){

        for(j in 1:nrow(splitted)){
          if(A[splitted$rhs[j], splitted$lhs[j]]!="0")
            stop("Redefinition of A[", splitted$rhs[j], ",", splitted$lhs[j], ".")
          A[splitted$rhs[j], splitted$lhs[j]] <- splitted$label[j]
        }

      }else if(all(splitted$operator == "~~")){

        for(j in 1:nrow(splitted)){
          if((S[splitted$rhs[j], splitted$lhs[j]]!="0") & (S[splitted$rhs[j], splitted$lhs[j]]!=splitted$label[j]))
            stop("Redefinition of S[", splitted$rhs[j], ",", splitted$lhs[j], ".")
          if((S[splitted$lhs[j], splitted$rhs[j]]!="0") & (S[splitted$lhs[j], splitted$rhs[j]]!=splitted$label[j]))
            stop("Redefinition of S[", splitted$lhs[j], ",", splitted$rhs[j], ".")
          if(splitted$label[j] == "0")
            splitted$label[j] <- "0.0" # to protect the value from automatically defined variances
          S[splitted$rhs[j], splitted$lhs[j]] <- splitted$label[j]
          S[splitted$lhs[j], splitted$rhs[j]] <- splitted$label[j]
        }

      }else if(all(splitted$operator == "~" &  splitted$rhs == "1")){

        for(j in 1:nrow(splitted)){
          if(M[1,splitted$lhs[j]]!="0")
            stop("Redefinition of M[1,", splitted$lhs[j], ".")
          M[1,splitted$lhs[j]] <- splitted$label[j]
        }

      }else if(all(splitted$operator == "~")){

        for(j in 1:nrow(splitted)){
          if(A[splitted$lhs[j], splitted$rhs[j]]!="0")
            stop("Redefinition of A[", splitted$lhs[j], ",", splitted$rhs[j], ".")
          A[splitted$lhs[j], splitted$rhs[j]] <- splitted$label[j]
        }

      }else{

        stop("Unknown operator ", splitted$operator, ".")

      }

    }

  }

  # fill covariances of initial time points
  maxLag <- lessTransformations:::.findMaxLag(occasions = occasions)

  S <- .fillCovariances(S = S,
                        latents = latents,
                        maxLag = maxLag)

  # we also take care of the initial means
  M <- .fillIntercepts(M = M,
                       latents = latents,
                       maxLag = maxLag)

  RAM <- new("RAM")
  RAM@A <- A
  RAM@S <- S
  RAM@M <- M
  RAM@F <- Fmat
  RAM@manifest <- rownames(Fmat)
  RAM@latent <- colnames(Fmat)[!colnames(Fmat) %in% rownames(Fmat)]

  return(RAM)
}

#' .removeWhitespace
#'
#' remove any whitespace from a string
#' @param syntax string
#' @return string with removed whitespace
.removeWhitespace <- function(syntax){
  return(gsub(pattern = "\\s|\\t", replacement = "", x = syntax))
}

#' .makeSingleLine
#'
#' combine multi-line statements into one line
#' @param syntax string
#' @return string with combined multi-line-statements
.makeSingleLine <- function(syntax){

  for(i in 1:length(syntax)){
    if(grepl(pattern = "[+*]$", x = syntax[i])){
      if(i == length(syntax))
        stop("Could not parse syntax. Your syntax seems to end with a + or a *.")
      syntax[i] <- paste0(syntax[i], syntax[i+1])
      syntax[i+1] <- ""
    }
  }

  syntax <- syntax[syntax != ""]
  return(syntax)
}

#' .getVariableNamesCLPM
#'
#' extracts the names of the variables from the syntax
#' @param syntax string
#' @return list with names of variables
#' @keywords internal
.getVariableNamesCLPM <- function(syntax){

  # remove all parameters
  syntax_t <- gsub(pattern = "[a-zA-Z0-9]+\\*|[a-zA-Z0-9]+_\\(u[\\-]*[0-9]*\\)\\*",
                   replacement = "",
                   x = syntax)
  # remove means
  syntax_t <- gsub(pattern = "~1",
                   replacement = "",
                   x = syntax_t)
  # split at operators
  variableNames <- unlist(stringr::str_split(string = syntax_t,
                                             pattern = "\\+|=~|~~|~"))

  # remove time indices
  isOccasionDependent <- grepl(pattern = "_\\(u[\\-]*[0-9]*\\)",
                               x = variableNames)
  variableNames <- gsub(pattern = "_\\(u[\\-]*[0-9]*\\)",
                        replacement = "",
                        x = variableNames)
  names(isOccasionDependent) <- variableNames

  return(
    list(occasionDependent = unique(variableNames[isOccasionDependent]),
         fixed = unique(variableNames[!isOccasionDependent]))
  )
}


#' .splitEquation
#'
#' splits an equation in left hand side, right hand side, label, and operator
#' @param equation string with equation
#' @return data.frame with left hand side, right hand side, label, and operator
#' @keywords internal
.splitEquation <- function(equation){

  if(grepl("~~", equation)){
    operator <- "~~"
    equation <- stringr::str_replace(string = equation,
                                     pattern = "~~",
                                     replacement = "~=~")
  }else if(grepl("=~", equation)){
    operator <- "=~"
    equation <- stringr::str_replace(string = equation,
                                     pattern = "=~",
                                     replacement = "~=~")
  }else if(grepl("~", equation)){
    operator <- "~"
    equation <- stringr::str_replace(string = equation,
                                     pattern = "~",
                                     replacement = "~=~")
  }

  splitted <- unlist(stringr::str_split(string = equation, pattern = "~=~"))

  lhs <- splitted[1]
  rhs <- splitted[2]

  rhsElements <- c()
  labels <- c()
  while(rhs != ""){
    label <- NULL
    rhsElement <- NULL

    if(grepl(pattern = "^[a-zA-Z0-9_]+\\*", x = rhs)){
      # starts with an modifier
      label <- stringr::str_extract(string = rhs,
                                    pattern = "^[a-zA-Z0-9_]+\\*")
      label <- stringr::str_remove(string = label,
                                   pattern = "\\*")

      rhs <- stringr::str_remove(string = rhs,
                                 pattern = "^[a-zA-Z0-9_]+\\*")
    }

    # now that we removed the modifier, our equation starts with a variable
    rhsElement <- stringr::str_extract(string = rhs,
                                       pattern = "^[a-zA-Z0-9_]+")

    # remove that element
    rhs <- stringr::str_remove(string = rhs,
                               pattern = "^[a-zA-Z0-9_]+[\\+]*")

    if(is.null(label)){
      label <- paste0(lhs, operator, rhsElement)
    }


    labels <- c(labels, label)
    rhsElements <- c(rhsElements, rhsElement)
  }

  separated <- data.frame(
    lhs = lhs,
    operator = operator,
    label = labels,
    rhs = rhsElements
  )

  return(separated)

}

#' .fillCovariances
#'
#' fills the covariances between latent variables which are considered initial covariances
#' @param S S matrix with undirected effects
#' @param latents data.frame with names of latent variables
#' @param maxLag larges lag in the equations
#' @return updated S matrix
#' @keywords internal
.fillCovariances <- function(S, latents, maxLag){
  latentNames <- paste0(latents$occasionDependent, "_u", rep(1:maxLag, each = length(latents$occasionDependent)))
  covs <- matrix(paste0("initialCov_",
                        rep(1:length(latentNames), each = length(latentNames)),
                        rep(1:length(latentNames), length(latentNames))),
                 nrow = length(latentNames), ncol = length(latentNames),
                 byrow = TRUE
  )

  S[latentNames, latentNames] <- covs

  return(S)
}

#' .fillIntercepts
#'
#' fills the intercepts for latent variables which are considered initial intercepts
#' @param M M matrix with means and intercepts
#' @param latents data.frame with names of latent variables
#' @param maxLag larges lag in the equations
#' @return updated M matrix
#' @keywords internal
.fillIntercepts <- function(M = M,
                            latents = latents,
                            maxLag = maxLag){

  latentNames <- paste0(latents$occasionDependent, "_u", rep(1:maxLag, each = length(latents$occasionDependent)))

  if(any(M[1, latentNames] != "0")){
    means <- matrix(paste0("initialMean_",
                           1:length(latentNames)),
                    nrow = 1, ncol = length(latentNames),
                    byrow = TRUE
    )
    M[1, latentNames] <- means
  }

  return(M)
}


#' .findMaxLag
#'
#' check the maximal time lag of the model
#' @param occasions data.frame with occasions
#' @return integer; larges time lag
#' @keywords internal
.findMaxLag <- function(occasions){
  if(all(occasions$string == "(u)"))
    return(0)
  removed_u <- stringr::str_remove_all(string = occasions$string,
                                       pattern = "\\(u[-]*|\\)")
  removed_u <- removed_u[removed_u!=""]
  return(max(as.numeric(removed_u)))
}
